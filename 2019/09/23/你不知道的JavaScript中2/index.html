<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="你不知道的JavaScript (中卷)2, 欢迎来到，瑞卿的窝。">
    <meta name="description" content="学习的小小笔记，记在这里。">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>你不知道的JavaScript (中卷)2 | 欢迎来到，瑞卿的窝。</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.0.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">欢迎来到，瑞卿的窝。</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">欢迎来到，瑞卿的窝。</div>
        <div class="logo-desc">
            
            学习的小小笔记，记在这里。
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/LRQLRQ" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/LRQLRQ" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/17.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">你不知道的JavaScript (中卷)2</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/javascript/">
                                <span class="chip bg-color">javascript</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-09-23
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="异步和性能"><a href="#异步和性能" class="headerlink" title="异步和性能"></a>异步和性能</h2><p>如何表达和控制持续一段时间的程序行为。是指程序的一部分<strong>现在运行</strong>，而另一部分在<strong>将来运行</strong>——现在和将来之间有间隙，在这段间隙中，程序没有活跃。<br>所有重要的程序(特别是 JavaScript 程序)都需要通过这样或那样的方法来管理这段时间间隙，这时可能是在等待用户输入、从数据库或文件系统中请求数据、通过网络发送数据并等待响应。在诸如此类的场景中，程序都需要管理这段时间间隙的状态。<br><strong>程序中现在运行的部分和将来运行的部分之间的关系，就是异步编程的核心</strong></p>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>JavaScript 引擎并不是独立运行的，它运行在<strong>宿主环境</strong>中，对多数开发者来说通常就是 Web 浏览器。最近几年 JavaScript 已经超出了浏览器的范围，进入了其他环境。比如通过像 node.js 这样的工具进入服务器领域。但是这些所有环境都有一个共同的“点”，即他们都提供了一种机制来处理程序中多个块的执行，且执行每块时调用 JavaScript 引擎。这种机制被称为<strong>事件循环</strong>。<br>换句话说，JavaScript 引擎本身并没有时间的概念，只是一个按需执行 JavaScript 任意代码片段的环境。“事件”(JavaScript 代码执行)调度总是由包含它的环境进行。</p>
<p><code>setTimeOut(..)</code>并没有把你的回调函数挂在事件循环队列中，他所做的是设定一个定时器。当定时器到时，环境会把你的回调函数放在事件循环中，这样在未来某个时刻的 tick 会摘下并执行这个回调。假如此时事件循环中已经有 100 个项目了怎么办？它就得排在其他项目之后。这也解释了为什么<code>setTimeOut(..)</code>定时器的精度可能不高。只能保证你的回调函数不会在指定的时间间隔之前运行，可能在那个时刻，也可能在那个时刻之后运行。</p>
<h3 id="并行线程"><a href="#并行线程" class="headerlink" title="并行线程"></a>并行线程</h3><p>术语“异步”和“并行”常常被混为一谈，但实际上它们的意义完全不同。异步是<strong>现在</strong>和<strong>将来</strong>的时间间隙。而并行是关于能够同时发生的事情。</p>
<p>并行计算最常见的工具就是<strong>进程</strong>和<strong>线程</strong>。进程和线程独立运行，并可能同时运行：在不同的处理器，甚至不同的计算机上，但多个线程能够共享单个进程的内存。与之相对的是，事件循环把自身的工作分成一个个任务并顺序执行，不允许对共享内存并行访问和修改。通过分立线程中彼此合作的事件循环，并行和顺序执行可以共存。</p>
<p>并行线程的交替执行和异步事件的交替调度，其粒度是完全不同的。</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>{</span><br><span class="line">  a = a + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>{</span><br><span class="line">  a = a * <span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ajax(<span class="string">"http://some.url.1"</span>, foo);</span><br><span class="line">ajax(<span class="string">"http://some.ur2.1"</span>, bar);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>完整运行</strong><br>JavaScript 单线程运行特性，所以 foo()和 bar()中的代码具有原子性。也就是说，一旦 foo()开始运行，它的所有代码都会在 bar()中的任意代码运行之前完成。或者 bar()比 foo()运行的完整。这称为：<strong>完整运行</strong> 特性。</p>
<p>但是，同一段代码有两个可能输出意味着还是存在不确定性！！~但是，这种不确定性是在函数(事件)顺序级别上，而不是多线程情况下的语句顺序级别(或者说，表达式运算顺序级别)。换句话说，这一确定性要高于多线程情况。<br>在 JavaScript 特性中，这种函数顺序的不确定性，就是通常所说的<strong>竞态条件</strong>，foo()和 bar()相互竞争，看谁先运行。具体的说，因为无法可靠预测 a 和 b 的最终结果，所以才是竞态条件。</p>
<p>单线程事件循环是==并发==的一种形式。</p>
<p><strong>不交互</strong><br>两个或多个“进程”在同一个程序内并发地交替运行它们的步骤/事件时，如果这些任务彼此不相关，就不一定需要交互。<strong>如果进程间没有相互影响的话，不确定性是完全可以接受的</strong>。</p>
<p><strong>交互</strong><br>并发的“进程”需要相互交流，通过作用域或 DOM 间接交互。如果出现这样的交互，就需要对它们的交互进行协调以避免竞态的出现。</p>
<p><strong>协作</strong><br>一种并发合作方式，称为“并发协作”。<br>如下情况:</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">response</span>(<span class="params">data</span>) </span>{</span><br><span class="line">  res = res.concat(</span><br><span class="line">    <span class="comment">//创建一个新的变换数组并把所有data值加倍</span></span><br><span class="line">    data.map(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>{</span><br><span class="line">      <span class="keyword">return</span> val * <span class="number">2</span>;</span><br><span class="line">    })</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ajax(<span class="string">"http://some.url.1"</span>, response); <span class="comment">//异步的ajax请求</span></span><br></pre></td></tr></tbody></table></figure>

<p>当 ajax 请求返回结果之后，整个列表会映射到 res 中，如果记录只有几千条，就没什么关系，如果有 1000w 条记录的话，就可能需要运行很长时间了。这样的“进程”运行时，页面上的其他代码都不能运行，包括不能有其他的 response 调用或 UI 刷新，甚至像滚动、输入、按钮点击这样的用户事件。</p>
<p>所以要创建一个协作性更强更友好且不会霸占事件循环队列的并发系统，可以异步地批处理这些结果。每次处理之后返回事件循环，让其他等待事件有机会运行。如下：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">response</span>(<span class="params">data</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> chunk = data.splice( <span class="number">0</span>, <span class="number">1000</span> );     <span class="comment">//分块，将数据一次运算1000个</span></span><br><span class="line"></span><br><span class="line">    res = res.concat(</span><br><span class="line">        chunk.map( <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>{</span><br><span class="line">            <span class="keyword">return</span> val * <span class="number">2</span>;</span><br><span class="line">        });</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(data.length &gt; <span class="number">0</span>) {       <span class="comment">//如果还有数据，就接着调用</span></span><br><span class="line">        <span class="built_in">setTimeout</span>( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">            response( data );</span><br><span class="line">        }, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">ajax(<span class="string">"http://some.url.1"</span>, response);    <span class="comment">//异步的ajax请求</span></span><br></pre></td></tr></tbody></table></figure>

<p>把数据集合放在最多包含 1000 条项目的块中。这样，就确保了“进程”运行时间很短，即使这意味着需要更多后续“进程”，因为事件循环的交替运行会提高站点/APP 的响应(性能)。这里使用 setTimeout(..,0),进行异步调度，意思就是“把这个函数插入到当前事件循环队列的结尾处”。</p>
<p><strong>任务</strong>：<br>对于任务队列最好的理解方式：它是挂在事件循环队列的每个 tick 之后的一个队列。在事件循环的每个 tick 中，可能出现的异步动作不会导致一个完整的新事件添加到事件循环队列中，而会在当前 tick 的任务队列末尾添加一个项目。(一个任务)。提一下，promise 的异步特性是基于任务的。</p>
<p><strong>小结</strong><br>实际上，JavaScript 程序总是至少分为两块：第一块<strong>现在</strong>执行，下一块<strong>将来</strong>运行，以响应某个事件。尽管程序是一块一块执行的，但是所有这些块共享对程序作用域和状态的访问，所以对状态的修改都是在之前累积的修改之上进行的。<br>一旦有事件需要运行，事件循环就会运行，直到队列清空。事件循环的每一轮称为一个 tick。用户交互、IO 和定时器会向事件队列中加入事件。<br>任意时刻，一次只能从队列中处理一个事件。执行事件的时候，可能直接或间接地引发一个或多个后续事件。<br>并发是指两个或多个事件链随事件发展交替执行，以至于从更高的层次来看，就像是同时在运行(尽管在任意时刻只处理一个事件)。<br>通常需要对这些并发执行的“进程”(和操作系统中的进程不同)进行某种形式的交互协调，比如需要确保执行顺序或者需要防止竞态出现。这些“进程”也可以通过把自身分割为更小块，以便于其他“进程”插入进来。</p>
<p><strong>回调地狱</strong>：<br>我们的顺序阻塞式的大脑计划行为无法很好地映射到面向回调的异步代码。这就是回调方式最主要的缺陷：对于它们在代码中表达异步的方式，我们的大脑需要努力才能同步得上。</p>
<p><strong>Node 风格</strong>：<br>有一种常见的回调模式叫做“error-first 风格”，有时也叫 Node 风格，因为几乎所有的 Node.js API 都会采用这种风格。其中回调的第一个参数保留用作错误对象(如果有的话)，如果成功的话，这个参数就会被清空/置假(后续的参数就是成功数据)。不过，如果产生了错误结果，那么第一个参数就会被置起/置真(通常就不会再传递其他结果)：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">response</span>(<span class="params">err, data</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (err) {</span><br><span class="line">    <span class="comment">//出错？</span></span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">//否则认为成功</span></span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">ajax(<span class="string">"http://some.url.1"</span>, response);</span><br></pre></td></tr></tbody></table></figure>

<p>下面展示一个工具：验证概念版本</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeoutify</span>(<span class="params">fn, delay</span>) </span>{</span><br><span class="line">  <span class="comment">//这个setTimeout会隔一段delay的时间</span></span><br><span class="line">  <span class="comment">//再把这个function放到任务队列里面</span></span><br><span class="line">  <span class="comment">//到了时间，就抛出timeout错误</span></span><br><span class="line">  <span class="keyword">var</span> intv = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    intv = <span class="literal">null</span>;</span><br><span class="line">    fn(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Timeout!"</span>));</span><br><span class="line">  }, delay);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//return的这个函数算是闭包了</span></span><br><span class="line">  <span class="comment">//里面有intv这个东西，会提升到全局变量吧</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="comment">//返回的函数判断一下intv是否存在</span></span><br><span class="line">    <span class="comment">//如果超时了delay就会置为null</span></span><br><span class="line">    <span class="comment">//没超时的话就把定时器清除掉</span></span><br><span class="line">    <span class="keyword">if</span> (intv) {</span><br><span class="line">      <span class="built_in">clearTimeout</span>(intv);</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    }</span><br><span class="line">  };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">err, data</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (err) {</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ajax(<span class="string">"http://someurl.1"</span>, timeoutify(foo, <span class="number">500</span>));</span><br></pre></td></tr></tbody></table></figure>

<p>ajax 异步调用请求需要耗费时间，如果响应很快，500ms 以内就能响应，那就调用了<code>timeoutify</code>返回的那个函数，在函数里面执行相应的逻辑：500ms 还没到， 定时器的任务还没执行，intv 还是真值，判断后清除这个定时器，然后让 foo 函数在 ajax 回调的环境中执行。猜测，ajax 必定至少返回两个参数，一个是 err 的位置，返回的必然是 null，另一个是 data 的位置，应该返回相应的请求数据。</p>
<p><strong>小结</strong><br>回调函数是 JavaScript 异步的基本单元。但是随着 JavaScript 越来越熟，对于异步编程领域的发展，回调已经不够用了。</p>
<ol>
<li>大脑对于事情的计划方式是线性的、阻塞的、单线程的语义，但是回调表达异步流程的方式是非线性的，非顺序的，这使得正确推导这样的代码难度很大。难于理解的代码是坏代码，会导致 bug。</li>
<li>更重要的一点是，回调会受到控制翻转的影响！因为回调会把控制权交给第三方(通常是不受控制的第三方工具！)来调用代码中的<code>continuation</code>。这种控制转移导致一系列麻烦的信任问题，比如回调的次数是否会超出预期。</li>
</ol>
<p>可以发明一些特定的逻辑来解决这些信任问题，但是其难度高于应有的水平，可能会产生更笨重、更难维护的代码。并且缺少足够的保护，其中的损害要直到受到 bug 的影响才会被发现。</p>
<h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>一但我需要的值准备好了，我就用我的承诺值换取这个值本身。</p>
<p>从外部看，由于 Promise 封装了依赖于时间的状态——等待底层值的完成或拒接，所以 Promise 本身是与时间无关的。因此，Promise 可以按照可预测的方式组成(组合)，而不用关心时序或底层的结果。</p>
<p>一旦 Promise 决议，它就永远保持在这个状态。此时它就成为了不变值，可以根据需求多次查看。Promise 决议后就是外部不可变的值，我们可以安全地把这个值传递给第三方，并确信它不会被有意无意地修改。特别是对于多方查看同一个 Promise 决议的情况，尤其如此。<br>Promise 是一种封装和组合未来值的易于复用的机制。</p>
<h4 id="具有-then-方法的鸭子类型"><a href="#具有-then-方法的鸭子类型" class="headerlink" title="具有 then 方法的鸭子类型"></a>具有 then 方法的鸭子类型</h4><p>如何判断某个值是不是 promise？既然 promise 是通过 new promise(..)语法创建的你可能认为使用 <code>p instanceof Promise</code>来判断，但是这种方式不足以作为检查方法。最重要的原因是，Promise 值可能是从其他浏览器窗口(iframe 等)接收到的，这个浏览器窗口自己的 Promise 可能和当前窗口/frame 的不同，因此这样的检查无法识别 Promise 实例。此外，库和框架可能会选择实现自己的 Promise，而不是使用原生 ES6 Promise 实现。实际上，很可能使用的是早期根本没有 Promise 实现的浏览器中使用由库提供的 Promise。</p>
<p>根据一个值的形态(具有哪些属性)对这个值的类型作出一些假定。这种类型检查一般用术语<strong>鸭子类型</strong>来表示——(如果它看起来像只鸭子，叫起来像只鸭子，那它一定就是鸭子)，于是检测大概就是这样：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if(</span><br><span class="line">    p !== null &amp;&amp;</span><br><span class="line">    (</span><br><span class="line">        typeof p === "object" ||</span><br><span class="line">        typeof p == "function"</span><br><span class="line">    ) &amp;&amp;</span><br><span class="line">    typeof p.then === "function"</span><br><span class="line">) {</span><br><span class="line">    //假定这就是一个thenable</span><br><span class="line">}</span><br><span class="line">else {</span><br><span class="line">    //不是一个thenable</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>假如在原型中加入了 then 函数，那么生成的对象就会被认定为 thenable 的。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.then = function() {};</span><br><span class="line">Array.prototype.then = function() {};</span><br><span class="line">var v1 = { hello: "world" };</span><br><span class="line">var v2 = [ "hello", "world"];</span><br></pre></td></tr></tbody></table></figure>

<p>v1 和 v2 都会被认作是 thenable。如果有任何代码无意或恶意地给 Object.prototype、Array.prototype 或任何原生原型添加 then(..)，如果有 Promise 决议到这样的值，就会永远挂住。</p>
<h4 id="Promise-的信任问题"><a href="#Promise-的信任问题" class="headerlink" title="Promise 的信任问题"></a>Promise 的信任问题</h4><p>把一个回调传入工具 foo(..)时，可能会出现如下问题：</p>
<ul>
<li>调用回调过早</li>
<li>调用回调过晚(或不被调用)</li>
<li>调用回调次数过少或过多</li>
<li>未能传递所需的环境和参数</li>
<li>吞掉可能出现的错误和异常<br>Promise 的特性就是专门用来为这些问题提供一个有效的可复用的答案。</li>
</ul>
<p><strong>调用过早</strong><br>根据定义，promise 就不必担心这种问题，因为即使是立即完成的 Promise,如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Promise( function(resolve) {</span><br><span class="line">    resolve(32);</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>也无法被同步观察到。也就是说，对一个 Promise 调用 then(…)的时候，即使这个 Promise 已经决议，提供给 then(..)的回调的总会被异步调用。</p>
<p><strong>调用过晚</strong><br>Promise 创建对象调用 resolve(..)或 reject(..)时，这个 promise 的 then(..)注册的观察回调就会被自动调度。一个 promise 决议后，这个 promise 上所有的通过 then(..)注册的回调都会在下一个异步时机点上依次被立即调用。这些回调中的任意一个都无法影响或延误对其他回调的调用。</p>
<p><strong>回调未调用</strong><br>没有任何东西(甚至是 JavaScript 错误)能阻止 Promise 向你通知它的决议(如果它决议了的话)。如果对一个 Promise 注册了一个完成回调和一个拒绝回调，那么 Promise 在决议时总是会调用其中的一个。</p>
<p><strong>调用次数过多或过少</strong><br>根据定义，回调被调用的正确次数应该是 1.“过少”的调用次数就是 0 次，和前面解释的唯美调用是一个道理。“过多”的情况很容易解释。Promise 的定义方式使得它只能被决议一次，如果出于某种原因，Promise 创建的代码试图调用 resolve(..)或 reject(..)多次，或者试图两者都调用，那么这个 Promise 将只会接受第一次决议，并默默地忽略任何后续调用。由于 Promise 只能被决议一次，所以任何通过 then(..)注册的(每个)回调就只会被调用一次。</p>
<p><strong>未能传递参数/环境值</strong><br>Promise 最多只能有一个决议值(完成或拒绝)。<br>如果没有用任何值显式决议，那么这个值就是<code>undefined</code>,这是 JavaScript 常见的处理方式。但不管这个值是什么，无论当前或未来，他都会被传给所有注册的(且适当的完成或拒绝)回调。<br>此外，如果使用多个参数调用 resolve(..)或者 reject(..)，第一个参数之后的所有参数都会被默默忽略。如果要传递多个值，就必须要把它们封装在单个值中传递，比如通过一个数组或对象。</p>
<p><strong>吞掉错误或异常</strong><br>如果拒绝一个 promise 并给出一个理由(也就是一个出错信息)，这个值就会被传给拒绝回调。如果在 promise 的创建过程中或在查看决议过程中的任意时间点，出现了一个 JavaScript 异常错误，比如一个 TypeError 或 ReferenceError，那这个异常就会被捕捉，并且会使这个 promise 被拒绝。</p>
<p><strong>链式流</strong><br>Promise并不只是一个单步执行this-then-that操作的机制，我们可以把多个Promise连接到一起以表示一系列异步步骤。<br>这种方式可以实现的关键在于以下两个Promise固有行为特性：  </p>
<ul>
<li>每次对Promise调用then(..)，他都会创建并返回一个新的promise，我们可以将其链接起来。</li>
<li>不管从then(..)调用的完成回调(第一个参数)返回的值是什么，它都会被自动设置为被链接Promise(第一点中的)的完成。  </li>
</ul>
<p>一个链式的demo：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve( <span class="number">21</span> );</span><br><span class="line"></span><br><span class="line">p.then( <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log( v );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个promise并返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params"> resolve, reject </span>) </span>{</span><br><span class="line">        <span class="comment">//这里是一些异步操作</span></span><br><span class="line">        <span class="built_in">setTimeout</span>( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">            resolve( v * <span class="number">2</span>);</span><br><span class="line">        }, <span class="number">1000</span>);</span><br><span class="line">    });</span><br><span class="line">})</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>{</span><br><span class="line">    <span class="comment">//上一个promise1000ms后执行这个</span></span><br><span class="line">    <span class="built_in">console</span>.log( v );   <span class="comment">//42</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>
<p>将这种链式的异步链接封装为一个工具，以便多个步骤调用，如下:</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">time</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>{</span><br><span class="line">        <span class="built_in">setTimeout</span>(resolve, time );</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">delay( <span class="number">100</span> )  <span class="comment">//步骤1</span></span><br><span class="line">.then( <span class="function"><span class="keyword">function</span> <span class="title">STEP2</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"在第一步过后的100ms，进行第二步"</span>);</span><br><span class="line">    <span class="keyword">return</span> delay( <span class="number">200</span> );</span><br><span class="line">})</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span> <span class="title">STEP3</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"第二步过后的200ms，进行第三步"</span>);</span><br><span class="line">    <span class="keyword">return</span> delay( <span class="number">300</span> );</span><br><span class="line">})</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span> <span class="title">STEP4</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"第三步过后的300ms，进行第四步"</span>);</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>假如promise链中的某个步骤出错了会怎么样？错误和异常是基于每个promise的，这意味着可能在链的任意位置捕捉到这样的错误，而这个捕捉动作在某种程度上就相当于将整条链“重置”到了正常运作,如下：  </p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前置操作</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>{</span><br><span class="line">        <span class="comment">//ajax()回调应该是我们这个promise的resolve函数</span></span><br><span class="line">        ajax( url, resolve);</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤1</span></span><br><span class="line">request( <span class="string">"http://some.url.1/"</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤2</span></span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">response1</span>)</span>{</span><br><span class="line">    foo.bar();  <span class="comment">//undefined出错</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//永远走不到这里</span></span><br><span class="line">    <span class="keyword">return</span> request( <span class="string">"http://some.url.2/?v="</span> + response1 );</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤3</span></span><br><span class="line">.then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">response2</span>) </span>{</span><br><span class="line">        <span class="comment">//永远不会到这里    </span></span><br><span class="line">    },</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>) </span>{</span><br><span class="line">        <span class="built_in">console</span>.log( err );</span><br><span class="line">        <span class="comment">//来自foo.bar()的错误TypeError</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    }</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤4</span></span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log( msg );     <span class="comment">//42  上一个步骤的错误返回值</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>
<p>第2步出错后，第3步的拒绝函数会捕捉到这个错误。如果有拒绝处理函数的返回值的话，会用来完成交给下一个步骤的promise。这样，这个链现在就回到了完成状态。  </p>
<p>如果没有给then(..)传递一个适当有效的函数作为完成处理函数参数，还是会有作为替代的一个默认处理函数：  </p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve( <span class="number">42</span> );</span><br><span class="line"></span><br><span class="line">p.then(</span><br><span class="line">    <span class="comment">//假定的完成处理函数，如果省略或者传入任何非函数值</span></span><br><span class="line">    <span class="comment">//function(v) {</span></span><br><span class="line">    <span class="comment">//    return v;</span></span><br><span class="line">    <span class="comment">//}</span></span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params"> err </span>) </span>{</span><br><span class="line">        <span class="comment">//到不了这里，因为promise直接被resolve了</span></span><br><span class="line">    }</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>
<p>默认的完成处理函数，会把接收到的任何传入值传递给下一个步骤(promise).<br><strong><code>then(null, function(err){..})</code>这个模式——只处理拒绝，但又把完成值传递下去，它有一个缩写形式的API:<code>catch(function(err) {..})</code></strong>  </p>
<p>总结一下使链式流程控制可行的Promise固有特性:  </p>
<ul>
<li>调用Promise的then(..)会自动创建一个新的Promise从调用返回</li>
<li>在完成或拒绝处理函数内部，如果返回一个值或抛出一个异常，新返回的(可链接的)Promise就响应地决议。  </li>
<li>如果完成或拒绝处理函数返回一个Promise，他会将被展开，这样一来，无论它的决议值是什么，都会成为当前then(..)返回的链接promise的决议值。</li>
</ul>
<p><code>Promise.resolve()</code> 会将传入的真正Promise直接返回，对传入的<code>thenable</code>则会展开。</p>
<p><strong>术语：决议、完成以及拒绝</strong><br>看一下Promise的构造器:</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">X,Y</span>)</span>{</span><br><span class="line">    <span class="comment">// X(); //用于完成</span></span><br><span class="line">    <span class="comment">// Y(); //用于拒绝</span></span><br><span class="line">} );</span><br></pre></td></tr></tbody></table></figure>
<p>第一个函数标识Promise已经完成，第二个标识Promise被拒绝。代码的名称只是一个标识符，对引擎而言没有任何意义。</p>
<p><strong>错误处理</strong><br>同步处理错误，使用<code>try ..catch</code>;异步处理错误，有一种<code>error-first</code>回调风格:</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">cb</span>) </span>{</span><br><span class="line">    <span class="built_in">setTimeout</span>( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">var</span> baz.bar();</span><br><span class="line">            cb( <span class="literal">null</span>, x);   <span class="comment">//成功</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (err) {</span><br><span class="line">            cb(err)</span><br><span class="line">        }</span><br><span class="line">    }, <span class="number">100</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">foo( <span class="function"><span class="keyword">function</span>(<span class="params">err, val</span>) </span>{</span><br><span class="line">    <span class="keyword">if</span>(err) {</span><br><span class="line">        <span class="built_in">console</span>.log( err );</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">console</span>.log( val );</span><br><span class="line">    }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>
<p>写一个函数，传入的参数是一个回调函数，业务逻辑都在函数内部，只有按照逻辑完成或者出错后，给回调函数传递相应的参数。上面的例子，只有在baz.bar()调用会同步地立即成功或失败的情况下，<code>try..catch</code>才能工作，如果baz.bar()本身有自己的异步完成函数，其中的任何异步错误都将无法捕捉。  </p>
<p>门机制是要等待两个或更多并行/并发的任务都完成才能继续。完成的顺序并不重要，但是必须都要完成。Promise.all([..])需要一个参数，是一个数组，通常由promise实例组成。从Promise.all([..])调用返回的promise会收到一个完成消息。这是一个由所有传入promise的完成消息组成的数组，与指定顺序一致(与完成顺序无关)。传给Promise.all([..])的数组中的值可以是Promise、thenable，甚至是立即值。列表中的每个值都会通过Promise.resolve(..)过滤，以确保等待的是一个真正的Promise。  </p>
<p>有时有这种需求，只响应第一个跨过终点线的Promise，而抛弃其他的Promise，这就需要用到——<code>Promise.race([..])</code>，这中模式传统上称为门闩，但在Promise中称为竞态。<br>一旦有任何一个Promise决议为完成，Promise.race([..])就会完成；一旦有任何一个Promise决议为拒绝，他就会拒绝。  </p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>{</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>{ reject(<span class="string">"promise1"</span>)}, <span class="number">500</span>);</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>{</span><br><span class="line">    <span class="built_in">setTimeout</span>( <span class="function">()=&gt;</span> { resolve(<span class="string">"promise2"</span>)}, <span class="number">1000</span>);</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p1,p2])</span><br><span class="line">.then( <span class="function">(<span class="params">msg</span>)=&gt;</span>{<span class="built_in">console</span>.log(msg)} )</span><br></pre></td></tr></tbody></table></figure>
<p>这里写一个demo试一下，确实是第一个决议后的promise，无论是完成还是拒绝，都会返回第一个完成的结果。  </p>
<p><strong>all([..])和race([..])的变体</strong>  </p>
<ul>
<li>none([..])，这个模式类似于all([..])，不过完成和拒绝的情况互换了，所有的Promise都要被拒绝，即拒绝转化为完成值。  </li>
<li>any([..])，这个模式和all([..])类似，但是会忽略拒绝，所以只需要完成一个而不是全部。  </li>
<li>first([..]) 这个模式类似于与any([..])的竞争。即只要第一个Promise完成，它就会忽略后续的任何拒绝和完成。  </li>
<li>last([..])这个模式类似于first([..])，但却是最后一个完成胜出。  </li>
</ul>
<h5 id="Promise-API概述"><a href="#Promise-API概述" class="headerlink" title="Promise API概述"></a>Promise API概述</h5><p><strong>new Promise(..)构造器</strong>  </p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resovle, reject</span>) </span>{</span><br><span class="line">    <span class="comment">//resolve(..)   用于决议/完成这个promise</span></span><br><span class="line">    <span class="comment">//reject(..)    用于拒绝这个promise</span></span><br><span class="line">})  </span><br></pre></td></tr></tbody></table></figure>
<p>reject(..)就是拒绝这个promise，但是resolve(..)既可能完成promise也可能拒绝。要根据传入的参数而定。如果传给resolve(..)的是一个非Promise、非thenable的立即值，这个promise就会用这个值完成。但是如果传给resolve(..)的是一个真正的Promise或thenable值，这个值就会被递归展开，并且(要构造的)promise将取用其最终决议值或状态。  </p>
<p><strong>then(..)和catch(..)</strong><br>每个promise实例(不是promise API命名空间)都有then(..)和catch(..)方法，通过这两个方法可以为这个Promise注册完成和拒绝处理函数。Promise决议之后，立即回调用这两个处理函数之一，但不会两个都调用，而且总是异步调用。<br>then(..)接受一个或两个参数：第一个用于完成回调，第二个用于拒绝回调。如果两者中的任何一个被省略或者作为非函数值传入的话，就会替换为相应的默认回调。默认完成回调<strong>只是把消息传递下去</strong>；默认拒绝回调<strong>则只是重新抛出(传播)其接收到的出错原因</strong>。  </p>
<p><strong>如果向Promise.all([..])传入空数组，它会立即完成， 但Promise.race([..])会挂住，且永远不会决议。</strong>  </p>
<h5 id="Promise的局限性"><a href="#Promise的局限性" class="headerlink" title="Promise的局限性"></a>Promise的局限性</h5><ul>
<li><p>顺序错误处理<br>在promise链中，假如中间的某个promise出了错误，链中的任何地方的任何错误都会在链中一直传播下去，直到被查看。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var p = foo(42);</span><br><span class="line">.then( STEP2)</span><br><span class="line">.then( STEP3);</span><br></pre></td></tr></tbody></table></figure>
<p>这里的p并不指向链中的第一个promise，而是指向最后一个promise，即来自调用then(STEP3)的那一个。很多时候并没有为Promise链序列的中间步骤保留的引用，没有这样的引用就无法关联错误处理函数来可靠地检查错误。  </p>
</li>
<li><p>无法取消的Promise<br>一旦创建了一个Promise并为其注册了完成或拒绝函数，如果出现某种情况使得这个任务悬而未决的话，开发者也没有办法从外部停止它的进程。  </p>
</li>
</ul>
<p>如果说Promise确实有一个真正的性能局限的话，那就是它们没有真正提供可信任性保护支持的列表以供选择(你总是得到全部)。  </p>
<ul>
<li>小结<br>promise解决了我们因只用回调的代码而备受困扰的<strong>控制反转</strong>问题。<br>是它们并没有摒弃回调，只是把回调的安排转交给了一个位于我们和其他工具之间的可信任的中介机制。  </li>
</ul>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>先看一段合作式并发的ES6代码：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>{</span><br><span class="line">    x++;</span><br><span class="line">    <span class="keyword">yield</span>;  <span class="comment">//暂停</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"x:"</span> , x);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>{</span><br><span class="line">    x++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面构造一个迭代器it来控制这个生成器</span></span><br><span class="line"><span class="keyword">var</span> it = foo();</span><br><span class="line"></span><br><span class="line">it.next();  <span class="comment">//启动foo()</span></span><br><span class="line">x;          <span class="comment">//2</span></span><br><span class="line">bar();      </span><br><span class="line">x;          <span class="comment">//3</span></span><br><span class="line">it.next();  <span class="comment">//x: 3</span></span><br></pre></td></tr></tbody></table></figure>
<p>运行流程：  </p>
<ol>
<li>it = foo()运算并没有执行生成器 *foo()，而只是构造了一个迭代器，这个迭代器会控制它的执行。  </li>
<li>第一个it.next()启动了生成器<code>*foo()</code>，并运行了<code>*foo()</code>的第一行的x++。</li>
<li><code>*foo()</code>在yield语句处暂停，在这里第一个it.next()的调用结束。此时<code>*foo()</code>仍然是活跃的，但处于暂停状态。</li>
<li>查看x的值，此时为2.</li>
<li>调用bar()，它通过x++再次递增x。</li>
<li>再次查看x的值，此时为3.</li>
<li>最后的it.next()调用从暂停处恢复了生成器<code>*foo()</code>的执行，并运行console.log(..)，此时当前x的值是3.</li>
</ol>
<p>显然foo()启动了，但是没有完整运行。它在yield处暂停了。后面恢复了foo()并让它运行到结束。但这不是必须的。生成器就是一类特殊的函数，可以一次或多次启动和停止，并不一定非得要完成。</p>
<p><strong>生成器的迭代消息传递</strong><br>除了能够接受参数并提供返回值之外，生成器甚至提供了更强大的内建消息输入输出能力，通过yield和next(..)实现。</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> y = x * (<span class="keyword">yield</span>);</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> it = foo(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">it.next();  <span class="comment">//启动foo(..)</span></span><br><span class="line"><span class="keyword">var</span> res = it.next(<span class="number">7</span>);   <span class="comment">//传参</span></span><br><span class="line"></span><br><span class="line">res.value;       <span class="comment">//42</span></span><br></pre></td></tr></tbody></table></figure>
<p>首先传入6作为参数x。然后调用it.next(),这会启动<code>*foo(..)</code>,在<code>*foo(..)</code>内部，开始执行赋值语句，但随后就遇到了一个yield表达式，它就会在这一点上暂停<code>*foo(..)</code>，并在本质上要求调用代码为yield表达式提供一个结果值。接下来，调用it.next(7)，这一句把值7传回作为被暂停的yield的表达式。  </p>
<p>yield和next(..)调用有一个不匹配，一般来说，next()要比yield语句多一个。为什么呢？因为第一个next(..)总是启动一个生成器，并运行到第一个yield处。不过，是第二个next(..)调用完成第一个被暂停的yield表达式，第三个next(..)调用完成第二个yield，以此类推。  </p>
<p>消息是双向传递的——yield..作为一个表达式可以发出消息响应next(..)调用，next(..)也可以向暂停的yield表达式发送值。</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> y = x * (<span class="keyword">yield</span> <span class="string">"Hello"</span>);</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">var</span> res = it.next();    <span class="comment">//第一个next，开启生成器</span></span><br><span class="line">res.value               <span class="comment">// "Hello"</span></span><br><span class="line"></span><br><span class="line">res = it.next(<span class="number">7</span>);       <span class="comment">//向等待的yield传入7</span></span><br><span class="line">res.value;              <span class="comment">//42</span></span><br></pre></td></tr></tbody></table></figure>
<p>yield..和next(..)这一对组合起来，<strong>在生成器的执行过程中</strong>构成了一个双向信息传递系统。  </p>
<p>我们并没有向第一个next()调用发送值，只有暂停的yield才能接受这样一个通过next(..)传递的值，而在生成器的起始处我们调用第一个next()时，还没有暂停的yield来接受这样一个值。规范和所有兼容浏览器都会默默丢弃传递给第一个next()的任何东西。<br>next()提出问题，yield回答问题。但是next()比yield要多一个，最后就由return来回答最后一个问题！  </p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">刘瑞</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://lrqlrq.github.io/2019/09/23/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B8%AD2/">https://lrqlrq.github.io/2019/09/23/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B8%AD2/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">刘瑞</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/javascript/">
                                    <span class="chip bg-color">javascript</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2019/09/23/Ajax%E5%AD%A6%E4%B9%A0/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/10.jpg" class="responsive-img" alt="学习Ajax">
                        
                        <span class="card-title">学习Ajax</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            ####Ajax应用的工作流程如下：

JavaScript脚本使用 XMLHttpRequest 对象向服务器发送请求。发送请求时，既可以发送GET请求，也可以发送POST请求。
JavaScript脚本使用 XMLHTTPRequest
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2019-09-23
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            刘瑞
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/ajx/">
                        <span class="chip bg-color">ajx</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/09/23/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B8%AD1/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/20.jpg" class="responsive-img" alt="你不知道的JavaScript(中卷)1">
                        
                        <span class="card-title">你不知道的JavaScript(中卷)1</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            第一部分 类型和语法第一章 类型这些工具库之所以功能强大，正是因为它们的开发者理解这门语言的本质和优点，并将它们运用到了极致。JavaScript 有 7 中内置类型：

空值（null）
未定义（undefined）
布尔值（boolea
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2019-09-23
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            刘瑞
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/javascript/">
                        <span class="chip bg-color">javascript</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="/about" target="_blank">刘瑞</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/LRQLRQ" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:lrq_email@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    

    

    

    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
